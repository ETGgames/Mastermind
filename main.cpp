//using c++11 features

#include <iostream>
#include <vector>
#include <math.h>
#include <chrono>

/// you can add other headers as needed
/// but only headers from the standard library
/// and not the algorithm header

/// do not use using namespace std
/// functions for random number generation, do not alter the declarations
void set_random_seed(); //remove all parameters from this function
int randn(int n);

/// you can define and use additional functions and structs,
/// add here the declarations for any other functions
/// and/or structs you wish to define and use
/// (the implementation for functions that don't belong to a struct
/// should be added after the main)
void printVector(const std::vector<int>& v);
void printVectorOfVectors(const std::vector<std::vector<int > >& v);
bool isIntInVector(int integer, const std::vector<int>& vector);
bool isVectorInVector(const std::vector<int>& vectorToCheck, const std::vector<std::vector<int > >& vector);


/// this is the struct definition for the code maker
/// do not alter the name
struct mm_code_maker{
	
	/// this member function sets the values for the member data
	/// representing the lenght of the code
	/// and the number of symbols (the symbols will be 0 to i_num)
	/// (this should be a constructor in proper OOP but ok)
	/// do not alter this function
	void init(int i_length, int i_num){
		length = i_length;
		num = i_num;
	}
	
	/// this member function generates a random sequence based
	/// on the length and num parameters stored as member data
	/// do not alter this function
	void generate_sequence(){
		for(int i = 0; i < length; i++){
			sequence.push_back(randn(num));
		}
	}
	/// do not alter name and parameter list for this function
	void give_feedback(const std::vector<int>& attempt, int& black_hits, int& white_hits){
		/// write here your implementation for this function
		/// which takes in input an attempt
		/// and provides feedback in terms of black hits
		/// and white hits (see linked paper)
		
		
		std::vector<int> attemptIndexesUsed;
		std::vector<int> sequenceIndexesUsed;
		black_hits = 0;
		white_hits = 0;
		
		//first find if there are black hits
		for(int i = 0; i < attempt.size(); i++){
			if(attempt[i] == sequence[i]){
				black_hits++;
				attemptIndexesUsed.push_back(i);
				sequenceIndexesUsed.push_back(i);
			}
		}
		
		//now find the white ones - only if they haven't been marked as black already
		for(int i = 0; i< attempt.size(); i++){
			for(int j = 0; j < sequence.size(); j++){
				if(!isIntInVector(i, attemptIndexesUsed) && !isIntInVector(j, sequenceIndexesUsed)){
					//make sure we are not re-using values
					if(attempt[i] == sequence[j]){
						white_hits++;
						
						attemptIndexesUsed.push_back(i);
						sequenceIndexesUsed.push_back(j);
					}
				}
			}
		}
		
	}
	
	/// member data holding the sequence generated by generate_sequence
	/// do not alter this
	std::vector<int> sequence;
	
	/// member data holding the values for length of code and number of symbols
	/// do not alter these
	int length;
	int num;
	
	/// do not add any other member data,
	/// in particular note that any variables needed for function give_feedback
	/// need to be declared within give_feedback
	/// (they are not member data of the struct)
	
	/// you may add other member functions if needed
};


/// this is the struct definition for the solver, do not alter the name
struct mm_solver{
	
	/// this member function sets the values for the member data
	/// representing the lenght of the code
	/// and the number of symbols (the symbols will be 0 to i_num)
	/// (this should be a constructor in proper OOP but ok)
	/// do not alter this function
	void init(int i_length, int i_num){
		length = i_length;
		num = i_num;
	}
	
	
	std::vector<int> definiteDigitsFound = {};
	bool movedOntoNewMagnitude = false;
	int digitToCreate = 0;
	
	bool quicklyFromNowOn = false;
	void createAttemptQuickly(std::vector<int>& attempt){//used for very big length and nums
		//std::cout << "\quickly called";
		
		quicklyFromNowOn = true;
		//auto startTimeCreateAttemptQuickly = std::chrono::high_resolution_clock::now();
		/// write your implementation here
		//int firstGuessPreCalculatedHighestPartitions = 0;
		
		//std::cout << "\ncreate attempt quickly called. definite digits found size " << definiteDigitsFound.size();
		
		
		std::vector<int> codeVectorToAdd;
		for(int j = length-1-(int)definiteDigitsFound.size(); j >= 0; j--){
			if (j == 0){
				codeVectorToAdd.push_back(digitToCreate);
			}else{
				codeVectorToAdd.push_back(-1);
			}
		}
		for (int i = (int)definiteDigitsFound.size(); i > 0; i--){
			codeVectorToAdd.push_back(definiteDigitsFound[i - 1]);
		}
		
		//std::cout << " \ndefitite digits ";
		printVector(definiteDigitsFound);
		attempt = codeVectorToAdd;
		digitToCreate++;
		
		
		numberOfAttemptsSoFar++;
		
		if (digitToCreate >= num){
			digitToCreate = 0;
		}
		
		
		//		auto endTimeCreateAttemptQuickly = std::chrono::high_resolution_clock::now();
		//		std::chrono::duration<double> timeElapsedForQuickAttempt = endTimeCreateAttemptQuickly - startTimeCreateAttemptQuickly;
		
	}
	
	bool mediumSpeedFromNowOn = false;
	void createAttemptMediumSpeed(std::vector<int>& attempt){
		//std::cout << "\nmedium speed called";
		if (quicklyFromNowOn){
			createAttemptQuickly(attempt);
			return;
		}
		mediumSpeedFromNowOn = true;
		
		//create code list, select random one maybe median, do an attempt and in learn remove all the ones that don't match black and white to reduce codelist size. then select another one (from startlist?) at random
		if (pow(num,length) > numberOfIterationsBeforeChangingAlgorithm){
			createAttemptQuickly(attempt);
			return;
		}
		if (masterList.size() < pow(num, length)){
			createMasterList(masterList);
			codeList = masterList;
			//std::cout << "\ncreated master list";
		}
		attempt = codeList[0];
	}
	/// this member function creates an attempt to find the right code
	/// (see the other examples provided for clarifications)
	/// do not alter the function interface (name, parameter list, void return)
	
	void create_attempt(std::vector<int>& attempt){
		/// write your implementation here
		//int firstGuessPreCalculatedHighestPartitions = 0;
		
		if (mediumSpeedFromNowOn){
			createAttemptMediumSpeed(attempt);
			return;
		}
		
		
		if (numberOfAttemptsSoFar == 0){
			//first attempt
			//std::cout << "\nmaster list will be size " << 1 << " code list will be size " << pow(num, length) << " mult to give " << 1 * pow(num, length);
			if (1 *  pow(num, length) > numberOfIterationsBeforeChangingAlgorithm){
				createAttemptMediumSpeed(attempt);
				return;
			}
			createMasterListForFirstAttempt(masterList);
		}
		if (numberOfAttemptsSoFar == 1){
			//second attempt
			
			//std::cout << "\nmaster list will be size " << pow(num, length) << " code list will be size " << codeList.size() << " mult to give " << pow(num, length) * codeList.size();
			
			if (pow(num, length) *  codeList.size() > numberOfIterationsBeforeChangingAlgorithm ){
				createAttemptMediumSpeed(attempt);
				return;
			}
			createMasterList(masterList);
		}
		
		if (codeList.size() * masterList.size() > numberOfIterationsBeforeChangingAlgorithm){
			//std::cout << "\nmaster list will be size " << masterList.size() << " code list will be size " <<  " mult to give " << codeList.size() * masterList.size();
			
			createAttemptMediumSpeed(attempt);
			return;
		}
		
		//we could call learn if this is the first go as we know what the attemp will be for the first go - 0012
		int highestNumberOfPartitions = 0;
		std::vector<int> guessWithHighestPartitions;
		
		
		for(int i = 0; i < masterList.size(); i++){
			int numberOfPartitionsForThisGuess = 0;
			std::vector<std::vector<int > > partitionsFoundForThisGuess;
			mm_code_maker maker;
			maker.init(length, num);
			maker.sequence = masterList[i];
			for(int j = 0; j < codeList.size(); j++){
				
				int black_hits = 0;
				int white_hits = 0;
				
				maker.give_feedback(codeList[j], black_hits, white_hits);
				std::vector<int> partition = {black_hits, white_hits};
				
				bool alreadyUsedPartition = false;
				
				for(int k = 0; k < partitionsFoundForThisGuess.size(); k++){
					if (partitionsFoundForThisGuess[k] == partition){
						alreadyUsedPartition = true;
					}
				}
				
				
				if (!alreadyUsedPartition){
					numberOfPartitionsForThisGuess++;
					partitionsFoundForThisGuess.push_back(partition);
				}
				
				
			}
			
			if (numberOfPartitionsForThisGuess > highestNumberOfPartitions){
				highestNumberOfPartitions = numberOfPartitionsForThisGuess;
				guessWithHighestPartitions = masterList[i];
				
			}
			
		}
		
		if (numberOfAttemptsSoFar == 0){
			//std::cout << "\nhighest number of partitions for first guess: " << highestNumberOfPartitions << "\n" ;
		}
		
		if (codeList.size() != 1){
			attempt = guessWithHighestPartitions;
		}else{
			attempt = codeList[0];
		}
		numberOfAttemptsSoFar++;//put this is if timer
		
	}
	
	/// this member function acquires the feedback about a certain attempt
	/// (see the other examples provided for clarifications)
	/// do not alter the function interface (name, parameter list, void return)
	void learn(std::vector<int>& attempt, int black_hits, int white_hits){
		
		/// write your implementation here
		std::vector<std::vector<int > > remainingGuesses;
		mm_code_maker maker;
		maker.init(length, num);
		maker.sequence = attempt;
		
		for (int i = 0; i < codeList.size(); i++){
			int black_hits_learn = 0;
			int white_hits_learn = 0;
			maker.give_feedback(codeList[i], black_hits_learn, white_hits_learn);
			if (black_hits_learn == black_hits && white_hits_learn == white_hits){
				remainingGuesses.push_back(codeList[i]);
			}
		}
		codeList = remainingGuesses;
		
		if (black_hits > definiteDigitsFound.size()){
			//std::cout << "\nblack hit found";
			definiteDigitsFound.push_back(attempt[attempt.size() - black_hits]);
			digitToCreate = 0;
		}
		
	}
	
	void createMasterListForFirstAttempt(std::vector<std::vector<int > >& list){
		list = {};
		
		if (length >= 3 && num >= 4){//we choose this because this is where there is a 2 on the end of the most likely first guess
			std::vector<int> codeVectorToAdd;
			int numberOfZeroes = length / 2;
			
			for (int i = 0; i < length - 1; i++){
				if (i < numberOfZeroes){
					codeVectorToAdd.push_back(0);
					
				}else{
					codeVectorToAdd.push_back(1);
				}
			}
			codeVectorToAdd.push_back(2);
			list.push_back(codeVectorToAdd);
			
			
		}
		
		//we still need to do this to create codeList
		for(int i = 0; i < pow(num, length) ; i++){
			std::vector<int> codeVectorToAdd;
			bool digitIsNot012 = false;
			
			bool digitsGoInOrder = true;
			int previousDigit = 0;
			
			for(int j = length-1; j >= 0; j--){
				int power = pow(num,j);
				int digit = (i/power) % num;
				codeVectorToAdd.push_back(digit);
				if (digit > 2){
					digitIsNot012 = true; //we do this because we know the first guess attempt will only ever contain 0, 1, or 2 (maybe eventually 3)(this is what we are assuming test this)
				}
				if (digit < previousDigit || digit - previousDigit > 1){
					digitsGoInOrder = false;
				}
				previousDigit = digit;
				
			}
			
			
			if (codeVectorToAdd[0] == 0 && !digitIsNot012 && digitsGoInOrder && (length < 3 || num < 4)){//only if the first digit is 0 push back because we know the best first attempt will always start with a 0 and only ones that we cannot create for certain as a first guesso
				list.push_back(codeVectorToAdd);
			}
			codeList.push_back(codeVectorToAdd);//code list still needs to be full of all possibilites
			
		}
		
		//printVectorOfVectors(codeList);
		
	}
	
	
	void createMasterList(std::vector<std::vector<int > >& list){
		list = {};
		for(int i = 0; i < pow(num, length); i++){
			std::vector<int> codeVectorToAdd;
			for(int j = length-1; j >= 0; j--){
				int power = pow(num,j);
				int digit = (i/power) % num;
				codeVectorToAdd.push_back(digit);
			}
			list.push_back(codeVectorToAdd);
		}
		
	}
	
	int numberOfAttemptsSoFar = 0;
	std::vector<std::vector<int > > masterList;
	std::vector<std::vector<int > > codeList;
	const int numberOfIterationsBeforeChangingAlgorithm = 1000000;
	
	
	int length;
	int num;
	
	/// you may add other memberp functions and member data as needed
	/// (keep in mind the distinction between member function variables
	/// and member data of the struct)
	
};

/// before the submission you need to remove the main
/// (either delete it or comment it out)
/// otherwise it will intefere with the automated testing
//
int main(){
	/// our program uses random features so we need to call the function setting a random seed
	set_random_seed();

	//the first value is

	int length, num;
	//std::cout << "enter length of sequence and number of possible values:" << std::endl;
	std::cin >> length >> num;


	/// we initialise the values for length and num

	std::vector<std::vector<int > > allPossibleGames;
	//
	//	for(int i = 0; i < pow(num, length); i++){
	//		std::vector<int> codeVectorToAdd;
	//		for(int j = length-1; j >= 0; j--){
	//			int power = pow(num,j);
	//			int digit = (i/power) % num;
	//			codeVectorToAdd.push_back(digit);
	//		}
	//		allPossibleGames.push_back(codeVectorToAdd);
	//	}

	std::vector<std::vector<int > > lengthNumCombos;

	for(int i = 0; i < 10; i++){
		std::vector<int> thisCombo;
		thisCombo.push_back(i + 1);

		for (int j = 0; j < 10; j++){
			thisCombo.push_back(j + 1);
			lengthNumCombos.push_back(thisCombo);
			thisCombo.pop_back();
		}
		thisCombo.pop_back();

	}
	//remove anything with 3 in it ---'''''
	//printVectorOfVectors(lengthNumCombos);

	int averageAttempts = 0;
	for (int i = 0; i < 1; i++){
		//double startTime = std::time(0);
		auto start = std::chrono::high_resolution_clock::now();
		//length = lengthNumCombos[i][0];
		//num = lengthNumCombos[i][1];
		//std::cout << "-------------------------------------";
		//std::cout << "\nNew guess with length " << length << " and num " << num << "";

		mm_solver solver;
		/// we declare an object of type mm_solver
		solver.init(length, num);
		mm_code_maker maker;
		/// we declare an object of type mm_code_maker
		maker.init(length, num);
		/// we initialise the values for length and num

		maker.generate_sequence();
		//maker.sequence = allPossibleGames[i];
		//maker.generate_sequence();//this is just temp for random
		/// we generate a random sequence
		int black_hits=0, white_hits=0;
		/// just some number to limit the number of attempts
		int attempts_limit = 50000;
		int attempts = 0;
		while((black_hits < length) && (attempts < attempts_limit)){
			std::cout << "===========================================\n";
			std::cout << "\nthe actual sequence is ";
			printVector(maker.sequence);
			auto startAttempt = std::chrono::high_resolution_clock::now();

			std::vector<int> attempt;
			solver.create_attempt(attempt);
			std::cout << "\nattempt given " ;
			printVector(attempt);
			std::cout << "\n ";

			if (attempts == 0){
				std::cout << "\nfirst guess is ";
				printVector(attempt);
			}
			if (attempts == 1){
				std::cout << "\nsecond guess is ";
				printVector(attempt);
			}
			//		//std::cout << "\nthe attempt is";
			//		printVector(attempt);
			/// the solver creates an attempt
			maker.give_feedback(attempt, black_hits, white_hits);
			/// we ask for feedback for the attempt

			/// we print the attempt
			//std::cout << "attempt: " << std::endl;
					for(int i = 0; i < attempt.size(); i++){
						//std::cout << attempt[i] << " ";
					}
			////std::cout << std::endl;
			/// we print the feedback
			std::cout << "\nblack pegs: " << black_hits << " " << " white pegs: " << white_hits << std::endl;
			// we give the feedback to the solver so that it can learn
			solver.learn(attempt, black_hits, white_hits);
			attempts++;
			auto endAttempt = std::chrono::high_resolution_clock::now();
			std::chrono::duration<double> elapsedAttempt = endAttempt - startAttempt;

			std::cout << "\nattempt time taken " << elapsedAttempt.count();
			std::cout << "\nmaster list size " << solver.masterList.size();
			std::cout << "\nremaining list size " << solver.codeList.size() << "\n";


		}

		if(black_hits == length){
			averageAttempts += attempts ;
			float average = (float)averageAttempts / (float)(i + 1);

			std::cout << "the solver has found the sequence in " << attempts << " attempts" << " with average of " << average <<  std::endl;
		}
		else{
			std::cout << "after " << attempts << " attempts still no solution" << std::endl;
		}
		std::cout << "the sequence generated by the code maker was:" << std::endl;
		for(int i = 0; i < maker.sequence.size(); i++){
			std::cout << maker.sequence[i] << " ";
		}
		std::cout << std::endl;

		auto end = std::chrono::high_resolution_clock::now();
		std::chrono::duration<double> elapsed = end - start;
		std::cout << "total game time taken was " << elapsed.count() << "\n";
		std::cout << "-------------------------------------\n\n\n";

	}//averaging loop

	//	float average = (float)averageAttempts / (float)attempts.size();
	//	//std::cout << "\nthe average number of attempts was: " << average;

	return 0;
}
/// not a great implementation for set_random_seed and for randn;
/// if you are trying to get better results you may want to change
/// the implementation using C++11 features, see for instance
/// https://isocpp.org/files/papers/n3551.pdf
/// but don't change the interface/declaration of the functions

void set_random_seed(){
	std::srand(std::time(0));
	
}

int randn(int n){
	return std::rand() % n;
}

/// add here the implementation for any other functions you wish to define and use

void printVector(const std::vector<int>& v){
	
	for(int i = 0; i < v.size(); i++){
		std::cout << v[i] << ", ";
	}
std::cout << std::endl;
}

void printVectorOfVectors(const std::vector<std::vector<int > >& v){
	for (int i = 0; i < v.size(); i++){
		for (int j = 0; j < v[i].size(); j++){
			std::cout << " " << v[i][j];
		}
		std::cout<<"\n";
	}
}

bool isIntInVector(int integer, const std::vector<int>& vector){
	for(int i = 0; i < vector.size(); i++){
		if(integer == vector[i]){
			return true;
		}
	}
	return false;
}

bool isVectorInVector(const std::vector<int>& vectorToCheck, const std::vector<std::vector<int > >& vector){
	for(int i = 0; i < vector.size(); i++){
		if(vectorToCheck == vector[i]){
			return true;
		}
	}
	return false;
}




#include <iostream>
#include <cstdlib>
#include <ctime>
#include <vector>
#include <math.h>
#include <map>

/// you can add other headers as needed
/// but only headers from the standard library
/// and not the algorithm header

/// do not use using namespace std

/// functions for random number generation, do not alter the declarations
void set_random_seed(int iter); //remove all parameters from this function
int randn(int n);

/// you can define and use additional functions and structs,
/// add here the declarations for any other functions
/// and/or structs you wish to define and use
/// (the implementation for functions that don't belong to a struct
/// should be added after the main)
void printVector(const std::vector<int> &v);
void printVectorOfVectors(const std::vector<std::vector<int> > &v);
bool isIntInVector(int integer, const std::vector<int> &vector);
bool isVectorInVector(const std::vector<int> &vectorToCheck, const std::vector<std::vector<int> > &vector);

/// this is the struct definition for the code maker
/// do not alter the name
struct mm_code_maker
{

	/// this member function sets the values for the member data
	/// representing the lenght of the code
	/// and the number of symbols (the symbols will be 0 to i_num)
	/// (this should be a constructor in proper OOP but ok)
	/// do not alter this function
	void init(int i_length, int i_num)
	{
		length = i_length;
		num = i_num;
	}

	/// this member function generates a random sequence based
	/// on the length and num parameters stored as member data
	/// do not alter this function
	void generate_sequence()
	{
		for (int i = 0; i < length; i++)
		{
			sequence.push_back(randn(num));
		}
	}
	/// do not alter name and parameter list for this function
	void give_feedback(const std::vector<int> &attempt, int &black_hits, int &white_hits)
	{
		/// write here your implementation for this function
		/// which takes in input an attempt
		/// and provides feedback in terms of black hits
		/// and white hits (see linked paper)
		//std::cout << "\n\ngiving feedback\n";
		//printVector(sequence);
		//printVector(attempt);

		std::vector<int> attemptIndexesUsed;
		std::vector<int> sequenceIndexesUsed;
		black_hits = 0;
		white_hits = 0;

		//first find if there are black hits
		for (int i = 0; i < attempt.size(); i++)
		{
			if (attempt[i] == sequence[i])
			{
				//std::cout << "\nfound black hit at index "<< i;
				black_hits++;
				attemptIndexesUsed.push_back(i);
				sequenceIndexesUsed.push_back(i);
			}
		}

		//now find the white ones - only if they haven't been marked as black already
		for (int i = 0; i < attempt.size(); i++)
		{
			for (int j = 0; j < sequence.size(); j++)
			{
				if (!isIntInVector(i, attemptIndexesUsed) && !isIntInVector(j, sequenceIndexesUsed))
				{
					//make sure we are not re-using values
					if (attempt[i] == sequence[j])
					{
						white_hits++;
						//std::cout << "\nwhite at i j "<< i << " " << j << "\n" ;

						attemptIndexesUsed.push_back(i);
						sequenceIndexesUsed.push_back(j);
					}
				}
			}
		}
	}

	/// member data holding the sequence generated by generate_sequence
	/// do not alter this
	std::vector<int> sequence;

	/// member data holding the values for length of code and number of symbols
	/// do not alter these
	int length;
	int num;

	/// do not add any other member data,
	/// in particular note that any variables needed for function give_feedback
	/// need to be declared within give_feedback
	/// (they are not member data of the struct)

	/// you may add other member functions if needed
};

/// this is the struct definition for the solver, do not alter the name
struct mm_solver
{

	/// this member function sets the values for the member data
	/// representing the lenght of the code
	/// and the number of symbols (the symbols will be 0 to i_num)
	/// (this should be a constructor in proper OOP but ok)
	/// do not alter this function
	void init(int i_length, int i_num)
	{
		length = i_length;
		num = i_num;
	}

	/// this member function creates an attempt to find the right code
	/// (see the other examples provided for clarifications)
	/// do not alter the function interface (name, parameter list, void return)
	void create_attempt(std::vector<int> &attempt)
	{
		/// write your implementation here
		//std::cout << "\ncreate attempt called\n";
		createMasterListIfNonExistent(masterList);
		//we could call learn if this is the first go as we know what the attemp will be for the first go - 0012
		int highestNumberOfPartitions = 0;
		std::vector<int> guessWithHighestPartitions;
		//std::cout << "about to use this code list\n"  << codeList.size();
		//printVectorOfVectors(codeList);
		//		for(int i = 0; i < codeList.size(); i++){
		//			std::vector<int> numberOfPartitionsKey = {-1};
		//			int numberOfPartitionsForThisGuess = storedResultsForEverything[codeList[i]][numberOfPartitionsKey][0];
		//			std::cout << "\nnumber of partitions for this guses" << numberOfPartitionsForThisGuess;
		//			if (numberOfPartitionsForThisGuess > highestNumberOfPartitions){
		//				highestNumberOfPartitions = numberOfPartitionsForThisGuess;
		//				guessWithHighestPartitions = codeList[i];
		//			}
		//
		//		}
		//		std::cout<< "\nguess with highest partitions :" << highestNumberOfPartitions << "|||" << "code list size: " << codeList.size() << "\n";
		//		printVector(guessWithHighestPartitions);
		//		attempt = guessWithHighestPartitions;

		for (int i = 0; i < masterList.size(); i++)
		{
			//std::cout << "masterlist i ";
			//printVector(masterList[i]);
			int numberOfPartitionsForThisGuess = 0;
			std::vector<std::vector<int> > partitionsFoundForThisGuess;

			for (int j = 0; j < codeList.size(); j++)
			{

				std::vector<int> partition = storedResultsForEverything[masterList[i]][codeList[j]];

				bool alreadyUsedPartition = false;

				for (int k = 0; k < partitionsFoundForThisGuess.size(); k++)
				{
					//std::cout << "3";

					if (partitionsFoundForThisGuess[k] == partition)
					{
						alreadyUsedPartition = true;
					}
				}

				if (!alreadyUsedPartition)
				{
					numberOfPartitionsForThisGuess++;
					partitionsFoundForThisGuess.push_back(partition);
				}
			}
			//			std::cout << "masterlist ";
			//			printVector(masterList[i]);
			//			std::cout  << "\nnumberOfPartitionsForThisGuess: " << numberOfPartitionsForThisGuess << "partitions\n";
			//			printVectorOfVectors(partitionsFoundForThisGuess);

			if (numberOfPartitionsForThisGuess > highestNumberOfPartitions)
			{
				highestNumberOfPartitions = numberOfPartitionsForThisGuess;
				guessWithHighestPartitions = masterList[i];
			}
		}

		//		std::cout<< "\nguess with highest partitions :" << highestNumberOfPartitions << "|||" << "code list size: " << codeList.size() << "\n";
		//		printVector(guessWithHighestPartitions);
		//
		//		attempt = guessWithHighestPartitions;

		if (codeList.size() != 1)
		{
			//			std::cout<< "\nguess with highest partitions :" << highestNumberOfPartitions << "|||" << "code list size: " << codeList.size() << "\n";
			//			printVector(guessWithHighestPartitions);

			attempt = guessWithHighestPartitions;
		}
		else
		{
			attempt = codeList[0];
		}
	}

	/// this member function acquires the feedback about a certain attempt
	/// (see the other examples provided for clarifications)
	/// do not alter the function interface (name, parameter list, void return)
	void learn(std::vector<int> &attempt, int black_hits, int white_hits)
	{
		/// write your implementation here
		std::vector<std::vector<int> > remainingGuesses;

		//std::cout << "remaining guesses before \n" ;
		//printVectorOfVectors(codeList);
		//
		//		mm_code_maker maker;
		//		maker.init(length, num);
		//		maker.sequence = attempt;
		//
		for (int j = 0; j < codeList.size(); j++)
		{
			if (storedResultsForEverything[attempt][codeList[j]][0] == black_hits && storedResultsForEverything[attempt][codeList[j]][1] == white_hits)
			{
				remainingGuesses.push_back(codeList[j]);
			}
			//
			//			int bh = 0;
			//			int wh = 0;
			//
			//			maker.give_feedback(codeList[j], bh, wh);
			//			if (bh == black_hits && wh == white_hits){
			//				remainingGuesses.push_back(codeList[j]);
			//			}
		}
		codeList = remainingGuesses;
		//		std::cout << "remaining guesses after \n" ;
		//		printVectorOfVectors(codeList);
		//

		//make guess list unique vector of remaining guesses
		//		codeList = {};
		//		for (int i = 0; i < remainingGuesses.size(); i++){
		//			if (!isVectorInVector(remainingGuesses[i], codeList)){
		//				codeList.push_back(remainingGuesses[i]);
		//			}
		//		}
		//		std::cout << "new guess list\n" << codeList.size() ;
		//		printVectorOfVectors(codeList);
	}

	void printStorageVector()
	{
		for (int i = 0; i < masterList.size(); i++)
		{
			std::cout << "**";
			printVector(masterList[i]);
			for (int j = 0; j < codeList.size(); j++)
			{
				std::cout << "    ";
				printVector(codeList[j]);
				std::cout << "                       &^";

				printVector(storedResultsForEverything[masterList[i]][codeList[j]]);
			}
		}
	}
	void getFeedbackForAllPossibilities()
	{ //doing this to stop having to calculate give feedback every time and hence speed things up
		/// write your implementation here
		std::cout << "\ngetFeedbackForAllPossibilities called\n";

		for (int i = 0; i < masterList.size(); i++)
		{
			//std::cout << "|\n";

			//			int numberOfPartitionsForThisGuess = 0;
			//			std::vector<std::vector<int>> partitionsFoundForThisGuess;

			mm_code_maker maker;
			maker.init(length, num);
			maker.sequence = masterList[i];
			//std::cout << "\nnext guess looped";
			for (int j = 0; j < codeList.size(); j++)
			{ //find partitions
				//std::cout << "||||\n";
				int black_hits = 0;
				int white_hits = 0;
				maker.give_feedback(codeList[j], black_hits, white_hits);
				//				std::vector<int> resultVector = {black_hits, white_hits};

				storedResultsForEverything[masterList[i]][codeList[j]].push_back(black_hits);
				storedResultsForEverything[masterList[i]][codeList[j]].push_back(white_hits);
				//
				//				bool alreadyUsedPartition = false;
				//
				//				for(int k = 0; k < partitionsFoundForThisGuess.size(); k++){
				//					//std::cout << "3";
				//
				//					if (partitionsFoundForThisGuess[k] == resultVector){
				//						alreadyUsedPartition = true;
				//					}
				//				}
				//
				//
				//				if (!alreadyUsedPartition){
				//					numberOfPartitionsForThisGuess++;
				//					partitionsFoundForThisGuess.push_back(resultVector);
				//				}
				//std::cout << "\npartitions found size: " << partitionsFoundForThisGuess.size() ;
			}
		}
		std::cout << "\ngetFeedbackForAllPossibilities ended \n";
		//printStorageVector();
	}

	void createMasterListIfNonExistent(std::vector<std::vector<int> > &masterList)
	{
		if (masterList.empty())
		{
			for (int i = 0; i < pow(num, length); i++)
			{
				std::vector<int> codeVectorToAdd;
				for (int j = length - 1; j >= 0; j--)
				{
					int power = pow(num, j);
					int digit = (i / power) % num;
					codeVectorToAdd.push_back(digit);
				}
				//printVector(codeVectorToAdd);
				masterList.push_back(codeVectorToAdd);
			}
			//std::cout << "master list size " << masterList.size() << " ";
			//possibleRemainingCodes = masterList;
			codeList = masterList;
			getFeedbackForAllPossibilities(); //this should only be calculated once
		}
	}

	std::vector<std::vector<int> > masterList; //vector of all possible values for the code
	//each code possibility is represented by a vector not an int or string.
	//std::vector<std::vector<int>> possibleRemainingCodes;
	std::vector<std::vector<int> > codeList;
	//std::vector<std::vector<int>> masterListStoredResults; //we only need to give feedback on every single possible combination once throughout the programme. therefore, calculate it once, store in this vector, then use this vector to lookup the result it would give //this is wrong but we need a way of storing everything so we don't need to calculate anything again, only retrieve.
	std::map<std::vector<int>, std::map<std::vector<int>, std::vector<int> > > storedResultsForEverything;
	//this will be in the form
	//	[guess1: [
	//	 			master1[
	//			  	black, white
	//			  	]
	//			  	master2[]
	//			  	master3[]
	//			  	master4[]
	//	, numberofpartitions
	//			  ]
	//	]
	//the last element will contain the number of partitions

	int length;
	int num;

	/// you may add other member functions and member data as needed
	/// (keep in mind the distinction between member function variables
	/// and member data of the struct)
};

/// before the submission you need to remove the main
/// (either delete it or comment it out)
/// otherwise it will intefere with the automated testing

int main()
{
	/// write the code for the main here in order to test your functions

	/// our program uses random features so we need to call the function setting a random seed

	int length, num;
	std::cout << "enter length of sequence and number of possible values:" << std::endl;
	std::cin >> length >> num;

	mm_solver solver;
	/// we declare an object of type mm_solver
	solver.init(length, num);
	/// we initialise the values for length and num
	int averageAttempts = 0;
	int numberOfRoundsToAverage = 50;
	/// we declare an object of type mm_code_maker
	for (int i = 0; i < numberOfRoundsToAverage; i++)
	{
		set_random_seed(i);

		solver.codeList = solver.masterList;
		mm_code_maker maker;
		maker.init(length, num);

		/// we initialise the values for length and num
		maker.generate_sequence();
		/// we generate a random sequence
		int black_hits = 0, white_hits = 0;
		/// just some number to limit the number of attempts
		int attempts_limit = 10;
		int attempts = 0;
		while ((black_hits < length) && (attempts < attempts_limit))
		{
			std::vector<int> attempt;
			solver.create_attempt(attempt);
			/// the solver creates an attempt
			maker.give_feedback(attempt, black_hits, white_hits);
			/// we ask for feedback for the attempt

			// we print the attempt
			//			std::cout << "\nattempt: " << std::endl;
			//			for(int i = 0; i < attempt.size(); i++){
			//				std::cout << attempt[i] << " ";
			//			}
			//			std::cout << std::endl;
			/// we print the feedback
			//std::cout << "black pegs: " << black_hits << " " << " white pegs: " << white_hits << std::endl;
			// we give the feedback to the solver so that it can learn
			solver.learn(attempt, black_hits, white_hits);
			attempts++;
		}

		if (black_hits == length)
		{
			averageAttempts += attempts;

			float average = (float)averageAttempts / (float)(i + 1);

			std::cout << "the solver has found the sequence in " << attempts << " attempts"
					  << " with average of " << average << std::endl;
		}
		else
		{
			std::cout << "after " << attempts << " attempts still no solution" << std::endl;
		}
		//		std::cout << "the sequence generated by the code maker was:" << std::endl;
		//		for(int i = 0; i < maker.sequence.size(); i++){
		//			std::cout << maker.sequence[i] << " ";
		//		}
		//		std::cout << std::endl;

	} //averaging loop
	float average = (float)averageAttempts / (float)numberOfRoundsToAverage;

	std::cout << "\nthe average number of attempts was: " << average;
	return 0;
}

/// not a great implementation for set_random_seed and for randn;
/// if you are trying to get better results you may want to change
/// the implementation using C++11 features, see for instance
/// https://isocpp.org/files/papers/n3551.pdf
/// but don't change the interface/declaration of the functions

void set_random_seed(int iter)
{
	std::srand(std::time(0) + iter); //reenable this later
									 //std::srand(700 + iter);
}

int randn(int n)
{
	return std::rand() % n;
}

/// add here the implementation for any other functions you wish to define and use

void printVector(const std::vector<int> &v)
{

	for (int i = 0; i < v.size(); i++)
	{
		std::cout << v[i] << ", ";
	}
	std::cout << std::endl;
}

void printVectorOfVectors(const std::vector<std::vector<int> > &v)
{
	for (int i = 0; i < v.size(); i++)
	{
		for (int j = 0; j < v[i].size(); j++)
		{
			std::cout << " " << v[i][j];
		}
		std::cout << "\n";
	}
}

bool isIntInVector(int integer, const std::vector<int> &vector)
{
	for (int i = 0; i < vector.size(); i++)
	{
		if (integer == vector[i])
		{
			return true;
		}
	}
	return false;
}

bool isVectorInVector(const std::vector<int> &vectorToCheck, const std::vector<std::vector<int> > &vector)
{
	for (int i = 0; i < vector.size(); i++)
	{
		if (vectorToCheck == vector[i])
		{
			return true;
		}
	}
	return false;
}
